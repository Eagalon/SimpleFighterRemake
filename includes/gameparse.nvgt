void charparse(const string&in path)
{
if(file_exists("data/layouts/characters/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/characters/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="shield type")
{
shieldtype=data[1];
}
if (data[0]=="shield weight")
{
shieldweight=parse_int(data[1]);
}
if (data[0]=="attack")
{
attack=parse_double(data[1]);
}
if (data[0]=="defence")
{
defence=parse_double(data[1]);
}
if (data[0]=="points")
{
points=parse_double(data[1]);
}
if (data[0]=="health")
{
health=parse_double(data[1]);
}
if (data[0]=="max health")
{
maxhealth=parse_double(data[1]);
}
if (data[0]=="lives")
{
lifecard=parse_double(data[1]);
}
if (data[0]=="level")
{
level=parse_double(data[1]);
}
if (data[0]=="level modifier")
{
levmod=parse_double(data[1]);
}
if (data[0]=="experience")
{
xp=parse_double(data[1]);
}
if (data[0]=="experience modifier")
{
xpmod=parse_double(data[1]);
}
if (data[0]=="experience required")
{
xprequiered=parse_double(data[1]);
}
if(data[0]=="death sound")
{
chardeathsound=parse_int(data[1]);
}
if(data[0]=="fall sound")
{
charfallsound=parse_int(data[1]);
}
if(data[0]=="fall sound2")
{
charfallsound2=parse_int(data[1]);
}
if(data[0]=="heal sound")
{
charhealsound=parse_int(data[1]);
}
if(data[0]=="heal sound2")
{
charhealsound2=parse_int(data[1]);
}
if(data[0]=="heal sound3")
{
charhealsound3=parse_int(data[1]);
}
if(data[0]=="hurt sound")
{
charhurtsound=parse_int(data[1]);
}
if(data[0]=="inv sound")
{
charinvsound=parse_int(data[1]);
}
if(data[0]=="jump sound")
{
charjumpsound=parse_int(data[1]);
}
if(data[0]=="lev sound")
{
charlevsound=parse_int(data[1]);
}
if(data[0]=="life sound")
{
charlifesound=parse_int(data[1]);
}
if(data[0]=="rock sound")
{
charrocksound=parse_int(data[1]);
}
if(data[0]=="sit sound")
{
charsitsound=parse_int(data[1]);
}
if(data[0]=="stand sound")
{
charstandsound=parse_int(data[1]);
}
if(data[0]=="turn sound")
{
charturnsound=parse_int(data[1]);
}
}
add_character(name, shieldtype, shieldweight, attack, defence, points, health, maxhealth, lifecard, level, levmod, xp, xpmod, xprequiered, chardeathsound, charfallsound, charfallsound2, charhealsound, charhealsound2, charhealsound3, charhurtsound, charinvsound, charjumpsound, charlevsound, charlifesound, charrocksound, charsitsound, charstandsound, charturnsound);
}
}
void arcparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/archery/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/archery/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void artparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/artillery/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/artillery/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void exoparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/explosive/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/explosive/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void meleparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/melee/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/melee/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void shieldparse(const string&in path)
{
if(file_exists("data/layouts/equipments/shields/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/shields/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="defence")
{
shielddefence=parse_int(data[1]);
}
if (data[0]=="weight")
{
shieldweight=parse_int(data[1]);
}
if (data[0]=="shield strength")
{
shieldstrength=parse_int(data[1]);
}
if (data[0]=="max shield strength")
{
maxshieldstrength=parse_int(data[1]);
}
if (data[0]=="unlock level")
{
shieldlevel=parse_double(data[1]);
}
if(data[0]=="break sound")
{
shieldbreaksound=parse_int(data[1]);
}
if(data[0]=="draw sound")
{
shielddrawsound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
shieldhitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
shieldloopsound=parse_int(data[1]);
}
if(data[0]=="remove sound")
{
shieldremovesound=parse_int(data[1]);
}
if(data[0]=="wear sound")
{
shieldwearsound=parse_int(data[1]);
}
}
add_shield(name, shielddefence, shieldweight, shieldstrength, maxshieldstrength, shieldlevel, shieldbreaksound, shielddrawsound, shieldhitsound, shieldloopsound, shieldremovesound, shieldwearsound);
}
}
void update_char_attack(const string& filename, double new_attack) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();        
        int attack_pos = string_contains(content, "attack=", 1);
        if (attack_pos != -1) {
            int value_start = attack_pos + 7;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_attack = string_trim_sides(content.substr(value_start, value_end));            
            string old_value = "attack=" + current_attack;
            string new_value = "attack=" + string(new_attack);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Attack stat updated successfully.");
                } else {
                    speak("Failed to write updated attack stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Attack stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_char_defence(const string& filename, double new_defence) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int defence_pos = string_contains(content, "defence=", 1);
        if (defence_pos != -1) {
            int value_start = defence_pos + 8;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_defence = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "defence=" + current_defence;
            string new_value = "defence=" + string(new_defence);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Defence stat updated successfully.");
                } else {
                    speak("Failed to write updated defence stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Defence stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_char_maxhealth(const string& filename, double new_maxhealth) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int maxhealth_pos = string_contains(content, "max health=", 1);
        if (maxhealth_pos != -1) {
            int value_start = maxhealth_pos + 11;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_maxhealth = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "max health=" + current_maxhealth;
            string new_value = "max health=" + string(new_maxhealth);
            content = string_replace(content, old_value, new_value, true);
            int health_pos = string_contains(content, "health=", 1);
            if (health_pos != -1) {
                value_start = health_pos + 7;
                value_end = string_contains(content.substr(value_start), "\r\n", 1);
                if (value_end == -1) value_end = content.length() - value_start;
                string current_health = string_trim_sides(content.substr(value_start, value_end));
                old_value = "health=" + current_health;
                new_value = "health=" + string(new_maxhealth);
                content = string_replace(content, old_value, new_value, true);
            }
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Max health and health stats updated successfully.");
                } else {
                    speak("Failed to write updated health stats to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Max health stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_char_lives(const string& filename, double new_lives) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();        
        int lives_pos = string_contains(content, "lives=", 1);
        if (lives_pos != -1) {
            int value_start = lives_pos + 6;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_lives = string_trim_sides(content.substr(value_start, value_end));            
            string old_value = "lives=" + current_lives;
            string new_value = "lives=" + string(new_lives);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("lives stat updated successfully.");
                } else {
                    speak("Failed to write updated lives stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("lives stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_wep_ammo(const string& weapontype, const string& weapontype2, double new_ammo) {
    string filename = "data/layouts/equipments/weapons/" + weapontype + "/" + weapontype2 + "/" + weapontype2 + ".sif";
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int ammo_pos = string_contains(content, "ammo=", 1);
        if (ammo_pos != -1) {
            int value_start = ammo_pos + 5;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_ammo = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "ammo=" + current_ammo;
            string new_value = "ammo=" + string(new_ammo);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Ammo stat updated successfully.");
                } else {
                    speak("Failed to write updated ammo stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Ammo stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading: " + filename);
    }
}
void update_wep_hl_range(const string& weapontype, const string& weapontype2, int new_hl_range) {
    string filename = "data/layouts/equipments/weapons/" + weapontype + "/" + weapontype2 + "/" + weapontype2 + ".sif";
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int range_pos = string_contains(content, "horizontal range=", 1);
        if (range_pos != -1) {
            int value_start = range_pos + 17;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_hl_range = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "horizontal range=" + current_hl_range;
            string new_value = "horizontal range=" + string(new_hl_range);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Horizontal range stat updated successfully.");
                } else {
                    speak("Failed to write updated horizontal range stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Horizontal range stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading: " + filename);
    }
}
void update_wep_vl_range(const string& weapontype, const string& weapontype2, int new_vl_range) {
    string filename = "data/layouts/equipments/weapons/" + weapontype + "/" + weapontype2 + "/" + weapontype2 + ".sif";
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int range_pos = string_contains(content, "vertical range=", 1);
        if (range_pos != -1) {
            int value_start = range_pos + 15;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_vl_range = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "vertical range=" + current_vl_range;
            string new_value = "vertical range=" + string(new_vl_range);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Vertical range stat updated successfully.");
                } else {
                    speak("Failed to write updated vertical range stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Vertical range stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading: " + filename);
    }
}
void update_shield_max_strength(const string& filename, double new_max_strength) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int max_strength_pos = string_contains(content, "max shield strength=", 1);
        if (max_strength_pos != -1) {
            int value_start = max_strength_pos + 20;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_max_strength = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "max shield strength=" + current_max_strength;
            string new_value = "max shield strength=" + string(new_max_strength);
            content = string_replace(content, old_value, new_value, true);
            int strength_pos = string_contains(content, "shield strength=", 1);
            if (strength_pos != -1) {
                value_start = strength_pos + 16;
                value_end = string_contains(content.substr(value_start), "\r\n", 1);
                if (value_end == -1) value_end = content.length() - value_start;
                string current_strength = string_trim_sides(content.substr(value_start, value_end));
                old_value = "shield strength=" + current_strength;
                new_value = "shield strength=" + string(new_max_strength);
                content = string_replace(content, old_value, new_value, true);
            }
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Max shield strength and shield strength stats updated successfully.");
                } else {
                    speak("Failed to write updated shield strength stats to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Max shield strength stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_shield_defence(const string& filename, double new_shield_defence) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int shield_defence_pos = string_contains(content, "defence=", 1);
        if (shield_defence_pos != -1) {
            int value_start = shield_defence_pos + 8;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_shield_defence = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "defence=" + current_shield_defence;
            string new_value = "defence=" + string(new_shield_defence);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Shield defence updated successfully.");
                } else {
                    speak("Failed to write updated shield defence to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Shield defence not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
