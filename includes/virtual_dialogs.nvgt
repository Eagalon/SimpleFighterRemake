/*
// Lisence
This code is shared to nvgt community and thus nvgt.gg licence applies to this code as well.
Written by Literary <literary-programmer on github>
*/

/*
Todo:
[priority] Find a way to use audio_form speach handler instead of screen_reader_speak function.
[priority] Find a way to add button translations for other languages.
[Priority] Add a way to reannounce form dialog if the window gains focus again.
{Optional} Find a way to play windows dialog sounds or may
[Optional] Add virtual popup.

*/

class virtual_dialogs
	{
	private audio_form form;
	private bool was_window_active;

	private void create_dialog(const string title)
		{
		this.form.create_window(title, false);
	}

	private void handle_arrow_keys()
		{
		int focus, count;

		focus = this.form.get_current_focus();
		count = this.form.get_control_count();
		if (count < 3)
			return;

		if (key_repeating(KEY_LEFT) || key_repeating(KEY_UP)) {
			focus --;
		} else if (key_repeating(KEY_RIGHT) || key_repeating(KEY_DOWN)) {
			focus ++;
		}

		if (focus == this.form.get_current_focus())
			return;

		if (focus < 1)
			focus = count -1;
		else if (focus >= count)
			focus = 1;

		this.form.focus_interrupt(focus);
	}

	bool info_box(const string title, const string label, const string text)
		{
		int text_box, close_button, cancel_button;

		this.form.reset();
		this.create_dialog(title);
		text_box = this.form.create_input_box(label, text, read_only = true, multiline = true);
		close_button = this.form.create_button("Close", true);
		cancel_button = this.form.create_button("Cancel", false, true);
		this.form.set_state(cancel_button, true, false);
		this.form.focus(text_box);
		while (true) {
			wait(5);
			this.form.monitor();
			if (this.form.is_pressed(close_button))
				return true;
			else if (this.form.is_pressed(cancel_button))
				break;

		}

		return false;
	}

	string input_box(const string title, const string text, const string default_text = "", const int flags = 0)
		{
		string result;
		int text_box, ok_button, cancel_button;

		this.form.reset();
		this.create_dialog(title);
		text_box = this.form.create_input_box(text, default_text);
		ok_button = this.form.create_button("OK", true);
		cancel_button = this.form.create_button("Cancel", cancel = true);
		this.form.focus(text_box);
		while (true) {
			wait(5);
			this.form.monitor();
			if (this.form.is_pressed(ok_button)) {
				result = this.form.get_text(text_box);
				break;
			} else if (this.form.is_pressed(cancel_button))
				break;

		}

		return result;
	}

	int message_box(const string title, const string caption, string[]@ buttons, int flags = 0)
		{
		int control, len, len2;
		int[] controls;
		bool primary, secondary;
		string button;

		this.form.reset();
		this.create_dialog(title);
		control = this.form.create_button("Cancel", false, true);
		controls.insert_last(control);
		len = buttons.length();
		for (uint i = 0; i < len; i ++) {
			button = buttons[i];
			primary = (button.starts_with("`")) ? true : false;
			secondary = (button.starts_with("~")) ? true : false;
			if (button.starts_with("`") || button.starts_with("~"))
				button = button.substr(1);

			control = this.form.create_button(button, primary, secondary, true);
			if (control != -1)
				controls.insert_last(control);

		}

		screen_reader_speak(caption, false);
		this.form.set_state(controls[0], true, false);
		if (controls.length() > 1)
			this.form.focus(controls[1]);

		len2 = controls.length();
		while (true) {
			wait(5);
			this.handle_arrow_keys();
			this.form.monitor();
			for (uint j = 0; j < len2; j ++) {
				control = controls[j];
				if (!this.form.is_pressed(control))
					continue;

				if (j == 0)
					return -1;

				return j;
			}
		}

		return -1;
	}

	int question(const string title, const string text, const bool can_cancel = false, const int flags = 0)
		{
		string[] controls = {"Yes", "No"};
		if (can_cancel)
			controls.insert_last("Cancel");

		return this.message_box(title, text, controls, flags);
	}

	int alert(const string title, const string text, const bool can_cancel = false, const int flags = 0)
		{
		string[] controls = {"OK"};
		if (can_cancel)
			controls.insert_last("Cancel");

		return this.message_box(title, text, controls, flags);
	}
}

int virtual_alert(const string title, const string text, const bool can_cancel = false, const int flags = 0)
	{
	virtual_dialogs vd;
	return vd.alert(title, text, can_cancel, flags);
}

bool virtual_info_box(const string title, const string label, const string text)
	{
	virtual_dialogs vd;
	return vd.info_box(title, label, text);
}

string virtual_input_box(const string title, const string text, const string default_text = "", const int flags = 0)
	{
	virtual_dialogs vd;
	return input_box(title, text, default_text, flags);
}

int virtual_message_box(const string title, const string caption, string[]@ buttons, const int flags = 0)
	{
	virtual_dialogs vd;
	return vd.message_box(title, caption, buttons, flags);
}

int virtual_question(const string title, const string text, const bool can_cancel = false, const int flags = 0)
	{
	virtual_dialogs vd;
	return vd.question(title, text, can_cancel, flags);
}
