string gmt(double x, double y)
{
string mt;
for(uint i=0; i<platforms.length(); i++)
{
if(platforms[i].minx<=x and platforms[i].maxx>=x and platforms[i].miny<=y and platforms[i].maxy>=y)
{
mt=platforms[i].tile;
tilevolume=platforms[i].volume;
tilepitch=platforms[i].pitch;
}
}
return mt;
}
string gct(double x, double y)
{
string ct;
for(uint i=0; i<platforms.length(); i++)
{
if(platforms[i].minx<=x and platforms[i].maxx>=x and platforms[i].miny<=y and platforms[i].maxy>=y)
{
ct=platforms[i].tile;
tilevolume=platforms[i].volume;
tilepitch=platforms[i].pitch;
}
}
return ct;
}
void clearmap()
{
destroy_all_blockages();
destroy_all_musicambs();
destroy_all_musicsources();
destroy_all_platforms();
destroy_all_ambsources();
destroy_all_soundsources();
destroy_all_reverb_effects();
destroy_all_spawnpoints();
destroy_all_staircases();
destroy_all_walls();
destroy_all_zones();
}
void destroymap()
{
destroy_all_animals();
destroy_all_animalzones();
destroy_all_belts();
destroy_all_bombs();
destroy_all_bombzones();
destroy_all_bullets();
destroy_all_calanders();
destroy_all_checkpoints();
destroy_all_clocks();
destroy_all_dialogs();
destroy_all_doors();
destroy_all_enemies();
destroy_all_enemiezones();
destroy_all_forcefields();
destroy_all_hazards();
destroy_all_healthzones();
destroy_all_lifts();
destroy_all_mines();
destroy_all_moving_hazards();
destroy_all_moving_platforms();
destroy_all_objs();
destroy_all_objzones();
destroy_all_psdoors();
destroy_all_pspassages();
destroy_all_passages();
destroy_all_projectiles();
destroy_all_projzones();
destroy_all_robots();
destroy_all_robotzones();
destroy_all_signs();
destroy_all_spikes();
destroy_all_teleporters();
destroy_all_text_squares();
destroy_all_timebombs();
destroy_all_timedmusics();
destroy_all_timedsources();
destroy_all_timedtexts();
destroy_all_travelpoints();
destroy_all_turrets();
destroy_all_vanishing_platforms();
destroy_all_vehicles();
destroy_all_zombies();
destroy_all_zombiezones();
}
void gop(int x, int y)
{
if(x<0 or x>maxx or y<0 or y>maxy)
{
dlg("error! You can't move out of map boundries! Please try again!");
}
else
{
me.x=x;
me.y=y;
speak("Moved to "+me.x+", "+me.y+".");
}
}
void load_map(string name, bool instant_update=false, bool speak_percentage=false, int loadtime=50, int loadbeeps=1, int loadsounds=1)
{
mapname=name;
clearmap();
destroymap();
if(string_ends_with(mapname,".map"))
{
mapname=string_replace(mapname,".map","",true);
}
string filename="data/maps/"+mapname+".map";
if(!file_exists(filename))
{
dlg("Error. This map is invalid. Please check the map name in the file and try again.");
mapmenu();
}
mapper.open(filename,"rb");
mapdata=mapper.read();
mapper.close();
sound mapload;
timer maploadtimer;
if(loadsounds==1) mpool.play_stationary("maploadstart.ogg",false);
if(loadsounds==1) mapload.load("maploading.ogg");
if(loadsounds==1) mapload.play_looped();
string[] lines=delinear(mapdata);
double percent=0;
int last_beep_percent=-1;
for (uint i=0; i<lines.length(); i++)
{
if(loadbeeps == 1)
{
double l=lines.length(), ind=i;
int current_percent=int(ind/l*100);
if(current_percent>last_beep_percent && maploadtimer.elapsed>=loadtime)
{
if(speak_percentage==true) speak(current_percent+" percent");
beep_percentage(current_percent);
last_beep_percent=current_percent;
maploadtimer.restart();
}
}        
if(!instant_update)
{
wait(5);
}
string[] sd=string_split(lines[i], " ", true);
if(sd[0]=="name" && sd.length()==2)
{
mapname=sd[1];
}
if(sd[0]=="maxx" && sd.length()==2)
{
maxx=stn(sd[1]);
}
if(sd[0]=="maxy" && sd.length()==2)
{
maxy=stn(sd[1]);
}
if(sd[0]=="platform" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
spawn_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch);
}
else if(sd[0]=="staircase" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string tiletype=sd[5];
double stairsvol=stn(sd[6]);
double stairspitch=stn(sd[7]);
spawn_staircase(mx, mx2, my, my2, tiletype, stairsvol, stairspitch);
}
else if(sd[0]=="vanishing_platform" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
string vplattype=sd[7];
double vplatvol=stn(sd[8]);
double vplatpitch=stn(sd[9]);
int sp=stn(sd[10]);
spawn_vanishing_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch, vplattype, vplatvol, vplatpitch, sp);
}
else if(sd[0]=="wall" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
string walltype=sd[6];
double wallvol=stn(sd[7]);
double wallpitch=stn(sd[8]);
bool dbl=string_to_bool(sd[9]);
spawn_wall(mx, mx2, my, my2, hp, hp, walltype, wallvol, wallpitch, dbl);
}
else if(sd[0]=="blockage" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_blockage(mx, mx2, my, my2, txt);
}
else if(sd[0]=="door" && sd.length()==14)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string lotype=sd[7];
string motype=sd[8];
string optype=sd[9];
string cotype=sd[10];
string dotype=sd[11];
bool amt=string_to_bool(sd[12]);
bool dbl=string_to_bool(sd[13]);
spawn_door(sx, sy, sx2, sy2, hp, hp, sp, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="psdoor" && sd.length()==15)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string drpass=sd[7];
string lotype=sd[8];
string motype=sd[9];
string optype=sd[10];
string cotype=sd[11];
string dotype=sd[12];
bool amt=string_to_bool(sd[13]);
bool dbl=string_to_bool(sd[14]);
spawn_psdoor(sx, sy, sx2, sy2, hp, hp, sp, drpass, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="passage" && sd.length()==11)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
int sp=stn(sd[5]);
string tiletype=sd[6];
string lotype=sd[7];
string optype=sd[8];
string cotype=sd[9];
int sp2=stn(sd[10]);
spawn_passage(sx, sy, dir, lt, sp, tiletype, lotype, optype, cotype, sp2);
}
else if(sd[0]=="pspassage" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
int sp=stn(sd[5]);
string tiletype=sd[6];
string lotype=sd[7];
string optype=sd[8];
string cotype=sd[9];
string pspass=sd[10];
int sp2=stn(sd[11]);
spawn_pspassage(sx, sy, dir, lt, sp, tiletype, lotype, optype, cotype, pspass, sp2);
}
else if(sd[0]=="zone" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_zone(mx, mx2, my, my2, txt);
}
else if(sd[0]=="reverb" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string id=sd[5];
float dry=stn(sd[6]);
float wet=stn(sd[7]);
float size=stn(sd[8]);
float damp=stn(sd[9]);
float width=stn(sd[10]);
spawn_reverb_effect(mx, mx2, my, my2, id, dry, wet, size, damp, width);
}
else if(sd[0]=="text_square" && sd.length()>=4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length());
spawn_text_square(x, y, txt);
}
else if(sd[0]=="clock" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string clocktype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_clock(x, y, txt, clocktype, dbl);
}
else if(sd[0]=="calander" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string calandertype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_calander(x, y, txt, calandertype, dbl);
}
else if(sd[0]=="music_ambience" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musicvol=stn(sd[6]);
double musicpitch=stn(sd[7]);
spawn_musicamb(mx, mx2, my, my2, musictype, musicvol, musicpitch);
}
else if(sd[0]=="music_source" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musvol=stn(sd[6]);
double muspitch=stn(sd[7]);
spawn_musicsource(mx, mx2, my, my2, musictype, musvol, muspitch);
}
else if(sd[0]=="sound_ambience" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
spawn_ambsource(mx, mx2, my, my2, sorcetype, soundvol, soundpitch);
}
else if(sd[0]=="sound_source" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sourcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
spawn_soundsource(mx, mx2, my, my2, sourcetype, soundvol, soundpitch);
}
else if(sd[0]=="timebomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string timbotype=sd[5];
spawn_timebomb(x, y, dmg, sp, timbotype);
}
else if(sd[0]=="timed_music" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musvol=stn(sd[6]);
double muspitch=stn(sd[7]);
int musictime=stn(sd[8]);
spawn_timedmusic(mx, mx2, my, my2, musvol, muspitch, musictime, musictype);
}
else if(sd[0]=="timed_source" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sourcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
int sourcetime=stn(sd[8]);
spawn_timedsource(mx, mx2, my, my2, soundvol, soundpitch, sourcetime, sourcetype);
}
else if(sd[0]=="timed_text" && sd.length()>=7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int texttime=stn(sd[5]);
string txt=join_string_array(sd, 6, sd.length());
spawn_timedtext(mx, mx2, my, my2, texttime, txt);
}
else if(sd[0]=="health_zone" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int hp=stn(sd[5]);
int ht=stn(sd[6]);
spawn_healthzone(mx, mx2, my, my2, hp, ht);
}
else if(sd[0]=="hazard" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string hazardtype=sd[5];
bool lgp=string_to_bool(sd[6]);
spawn_hazard(mx, mx2, my, my2, hazardtype, lgp);
}
else if(sd[0]=="lift" && sd.length()==13)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
double tilevol=stn(sd[8]);
double tilepitch=stn(sd[9]);
string lifttype=sd[10];
double liftvol=stn(sd[11]);
double liftpitch=stn(sd[12]);
spawn_lift(mx, mx2, my, my2, dir, sp, tiletype, tilevol, tilepitch, lifttype, liftvol, liftpitch);
}
else if(sd[0]=="mine" && sd.length()==5)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
string minetype=sd[4];
spawn_mine(x, y, dmg, minetype);
}
else if(sd[0]=="mhazard" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
double sy=stn(sd[6]);
int dir=stn(sd[7]);
int dir2=stn(sd[8]);
int sp=stn(sd[9]);
string hazardtype=sd[10];
spawn_moving_hazard(mx, mx2, my, my2, sx, sy, dir, dir2, sp, hazardtype);
}
else if(sd[0]=="mplatform" && sd.length()==16)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
int dir=stn(sd[6]);
int dir2=stn(sd[7]);
int sp=stn(sd[8]);
string tiletype=sd[9];
double tilevol=stn(sd[10]);
double tilepitch=stn(sd[11]);
string mplattype=sd[12];
double mplatvol=stn(sd[13]);
double mplatpitch=stn(sd[14]);
int vs=stn(sd[15]);
spawn_moving_platform(mx, mx2, my, my2, sx, dir, dir2, sp, tiletype, tilevol, tilepitch, mplattype, mplatvol, mplatpitch, vs);
}
else if(sd[0]=="sign" && sd.length()>=7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-3);
string signtype=sd[sd.length()-3];
bool dbl=string_to_bool(sd[sd.length()-2]);
bool lps=string_to_bool(sd[sd.length()-1]);
spawn_sign(x, y, txt, signtype, dbl, lps);
}
else if(sd[0]=="checkpoint" && sd.length()==5)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int checktime=stn(sd[3]);
string checktype=sd[4];
spawn_checkpoint(x, y, checktime, checktype);
}
else if(sd[0]=="dialog" && sd.length()>=8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length()-2);
string dlgtype=sd[sd.length()-2];
dlgtyp=dlgtype;
bool dlm=string_to_bool(sd[sd.length()-1]);
spawn_dialog(mx, mx2, my, my2, txt, dlgtype, dlm);
}
else if(sd[0]=="item" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int objtime=stn(sd[3]);
string objtype=sd[4];
string objtype2=sd[5];
bool automatic=string_to_bool(sd[6]);
spawn_obj(x, y, objtime, objtype, objtype2, automatic);
}
else if(sd[0]=="item_zone" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int sp=stn(sd[5]);
string objtype=sd[6];
string objtype2=sd[7];
spawn_objzone(mx, mx2, my, my2, sp, objtype, objtype2);
}
else if(sd[0]=="spike" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
string spiketype=sd[8];
bool dbl=string_to_bool(sd[9]);
spawn_spike(mx, mx2, my, my2, hp, hp, dmg, sp, spiketype, dbl);
}
else if(sd[0]=="spawnpoint" && sd.length()==3)
{
int spx=stn(sd[1]);
int spy=stn(sd[2]);
create_spawnpoint(spx, spy);
}
else if(sd[0]=="travelpoint" && sd.length()>=9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string destmap=sd[5];
int destx=stn(sd[6]);
int desty=stn(sd[7]);
string endtext=sd[8];
spawn_travelpoint(mx, mx2, my, my2, destmap, destx, desty, endtext);
}
else if(sd[0]=="animal" && sd.length()==18)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int anirange=stn(sd[3]);
int anirange2=stn(sd[4]);
int anirange3=stn(sd[5]);
int anirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string amtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
spawn_animal(x, y, anirange, anirange2, anirange3, anirange4, hp, hp, card, dmg, ft, sp, lv, xp, amtype, fb, mb, mb2);
}
else if(sd[0]=="enemie" && sd.length()==18)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int enerange=stn(sd[3]);
int enerange2=stn(sd[4]);
int enerange3=stn(sd[5]);
int enerange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string emtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
spawn_enemie(x, y, enerange, enerange2, enerange3, enerange4, hp, hp, card, dmg, ft, sp, lv, xp, emtype, fb, mb, mb2);
}
else if(sd[0]=="forcefield" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dmg=stn(sd[5]);
int sp=stn(sd[6]);
string forcetype=sd[7];
spawn_forcefield(mx, mx2, my, my2, dmg, sp, forcetype);
}
else if(sd[0]=="projectile" && sd.length()==13)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dir=stn(sd[3]);
double hp=stn(sd[4]);
int card=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
double xp=stn(sd[9]);
string potype=sd[10];
bool fb=string_to_bool(sd[11]);
bool mb=string_to_bool(sd[12]);
spawn_projectile(x, y, dir, hp, hp, card, dmg, sp, lv, xp, potype, fb, mb);
}
else if(sd[0]=="robot" && sd.length()==18)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int roborange=stn(sd[3]);
int roborange2=stn(sd[4]);
int roborange3=stn(sd[5]);
int roborange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string rotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
spawn_robot(x, y, roborange, roborange2, roborange3, roborange4, hp, hp, card, dmg, ft, sp, lv, xp, rotype, fb, mb, mb2);
}
else if(sd[0]=="turret" && sd.length()==17)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int lt=stn(sd[7]);
int sp=stn(sd[8]);
double lv=stn(sd[9]);
double xp=stn(sd[10]);
string tutype=sd[11];
string tutype2=sd[12];
string tutype3=sd[13];
bool fb=string_to_bool(sd[14]);
bool mb=string_to_bool(sd[15]);
bool mb2=string_to_bool(sd[16]);
spawn_turret(x, y, hp, hp, card, dmg, ft, lt, sp, lv, xp, tutype, tutype2, tutype3, fb, mb, mb2);
}
else if(sd[0]=="zombie" && sd.length()==18)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int zombirange=stn(sd[3]);
int zombirange2=stn(sd[4]);
int zombirange3=stn(sd[5]);
int zombirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string zotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
spawn_zombie(x, y, zombirange, zombirange2, zombirange3, zombirange4, hp, hp, card, dmg, ft, sp, lv, xp, zotype, fb, mb, mb2);
}
else if(sd[0]=="animal_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string amtype=sd[5];
spawn_animalzone(mx, mx2, y, sp, amtype);
}
else if(sd[0]=="bomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bomb(x, y, dmg, sp, botype);
}
else if(sd[0]=="bomb_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bombzone(mx, mx2, y, sp, botype);
}
else if(sd[0]=="belt" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
string belttyp=sd[8];
spawn_belt(mx, mx2, my, my2, dir, sp, tiletype, belttyp);
}
else if(sd[0]=="enemie_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string emtype=sd[5];
spawn_enemiezone(mx, mx2, y, sp, emtype);
}
else if(sd[0]=="projectile_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string potype=sd[5];
spawn_projzone(mx, mx2, y, sp, potype);
}
else if(sd[0]=="robot_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string rotype=sd[5];
spawn_robotzone(mx, mx2, y, sp, rotype);
}
else if(sd[0]=="teleporter" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
int telrange=stn(sd[5]);
int telrange2=stn(sd[6]);
int sp=stn(sd[7]);
string teltype=sd[8];
bool mb=string_to_bool(sd[9]);
bool mb2=string_to_bool(sd[10]);
bool ss=string_to_bool(sd[11]);
spawn_teleporter(sx, sy, sx2, sy2, telrange, telrange2, sp, teltype, mb, mb2, ss);
}
else if(sd[0]=="vehicle" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int dmg=stn(sd[4]);
string vehtyp=sd[5];
bool fb=string_to_bool(sd[6]);
spawn_vehicle(x, y, hp, hp, dmg, vehtyp, fb);
}
else if(sd[0]=="zombie_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string zotype=sd[5];
spawn_zombiezone(mx, mx2, y, sp, zotype);
}
if(last_spawnpoint!is null)
{
me.x=last_spawnpoint.spawnx;
me.y=last_spawnpoint.spawny;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
else if(spawnpoints.length()>0)
{
me.x=spawnpoints[0].spawnx;
me.y=spawnpoints[0].spawny;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
else
{
me.x=me.x;
me.y=me.y;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
}
if(loadsounds==1) mapload.stop();
if(loadsounds==1) mpool.play_stationary("maploadstop.ogg",false);
if(loadbeeps == 1 && last_beep_percent<100)
{
if(speak_percentage==true) speak("100 "+"percent");
beep_percentage(100);
}
}
void create_map(string name, double mx, double my, string tiletype)
{
mapname=name;
maxx=mx;
maxy=my;
mapper.open("data/maps/"+name+".map","wb");
mapdata=mapper.read();
mapper.write("name "+mapname+"\r\n"+"maxx "+mx+"\r\n"+"maxy "+my+"\r\n"+"platform 0 "+mx+" 0 "+tiletype+" 0 100");
mapper.close();
spawn_platform(0, mx, 0, 0, tiletype, 0, 100);
}
void tutmap()
{
gametimer.force(gametime);
while(true)
{
wait(5);
update_ambsources(me.x,me.y);
update_musicambs(me.x,me.y);
update_sound_pools();
checkdeath();
checkloc();
checkpassages();
checkpspassages();
checkwepslots();
calandercheck();
clockcheck();
doorcheck();
fallcheck();
hazardcheck();
mhazardcheck();
mplatcheck();
psdoorcheck();
signcheck();
spawncheck();
stairscheck();
textcheck();
travelcheck();
wallcheck();
animalloop();
animalzoneloop();
beltloop();
bfloop();
bulletloop();
bombloop();
bombzoneloop();
cploop();
dlgloop();
doorloop();
eneloop();
enemiezoneloop();
forceloop();
healthzoneloop();
liftloop();
mineloop();
objloop();
objzoneloop();
psdoorloop();
projloop();
projzoneloop();
revfxloop();
robloop();
robotzoneloop();
spikeloop();
telloop();
timebombloop();
timedmrcloop();
timedsrcloop();
timedtxtloop();
turretloop();
vplatloop();
vehloop();
zombloop();
zombiezoneloop();
if (jumping==1)
{
movetime=airtime;
}
else if(alt_is_down())
{
movetime=runtime;
}
else
{
movetime=walktime;
}
if(modspeed>=1)
{
airtime=250/modspeed+shieldweight+wepweight;
camtime=250/modspeed+shieldweight+wepweight;
falltime=250/modspeed-shieldweight-wepweight;
runtime=500/modspeed+shieldweight+wepweight;
walktime=1000/modspeed+shieldweight+wepweight;
}
if(xp>=xprequiered)
{
xprequiered=(levmod*(level*(level*4)));
string[] levsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*lev*");
if(levsfx.length()!=0 and charlevsound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+levsfx[random(0,levsfx.length()-1)],false);
level+=1;
points+=100*level*levmod-100;
}
if(health<=health and hprestoretimer.elapsed>=hprestoretime and healable==true)
{
if(hprestoration==1)
{
string[] healingsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healing*");
if(healingsfx.length()!=0 and charhealsound==1) autoslot=p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healingsfx[random(0,healingsfx.length()-1)],false);
health+=maxhealth/4;
string[] healstopsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1 and health>=maxhealth) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
hprestoretimer.restart();
}
}
if(shieldstrength<=shieldstrength and sprestoretimer.elapsed>=sprestoretime and healable==true)
{
if(sprestoration==1)
{
string[] healingsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healing*");
if(healingsfx.length()!=0 and charhealsound==1) autoslot=p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healingsfx[random(0,healingsfx.length()-1)],false);
shieldstrength+=maxshieldstrength/4;
string[] healstopsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1 and shieldstrength>=maxshieldstrength) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
sprestoretimer.restart();
}
}
if(shieldstrength<=0)
{
p.destroy_sound(shieldloop);
p.destroy_sound(shieldslot);
string[] breaksfx=find_files("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*break*");
if(breaksfx.length()!=0 and shieldbreaksound==1) shieldslot=p.play_stationary_extended("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+breaksfx[random(0,breaksfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
shieldstrength=maxshieldstrength;
shieldon=0;
shieldweight=1;
shieldtype="none";
}
if(health<=0)
{
if(lifecard>=2)
{
string[] lifesfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*life*");
if(lifesfx.length()!=0 and charlifesound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+lifesfx[random(0,lifesfx.length()-1)],false);
lifecard-=1;
health=maxhealth;
}
}
if(animals.length()>=50 or enemies.length()>=50 or projectiles.length()>=50 or robots.length()>=50 or zombies.length()>=50)
{
aninum=50;
eninum=50;
projnum=50;
robnum=50;
zombnum=50;
}
if(me.x<=0)
{
me.x=0;
}
if(me.x>=maxx)
{
me.x=maxx;
}
if(me.y<=0)
{
me.y=0;
}
if(me.y>=maxy)
{
me.y=maxy;
}
if(health<=0)
{
health=0;
}
if(health>=maxhealth)
{
health=maxhealth;
}
if(shieldstrength<=0)
{
shieldstrength=0;
}
if(shieldstrength>=maxshieldstrength)
{
shieldstrength=maxshieldstrength;
}
if(attack<=0)
{
attack=0;
}
if(defence<=0)
{
defence=0;
}
if(lifecard<=1)
{
lifecard=1;
}
if(points<=0)
{
points=0;
}
if(shielddefence<=0)
{
shielddefence=0;
}
if(weprange<=0)
{
weprange=0;
}
if(weprange2<=0)
{
weprange2=0;
}
if(health>=maxhealth and hprestoration==1)
{
hprestoration=0;
p.destroy_sound(autoslot);
health=maxhealth;
}
if(shieldstrength>=maxshieldstrength and sprestoration==1)
{
sprestoration=0;
p.destroy_sound(autoslot);
shieldstrength=maxshieldstrength;
}
if(key_pressed(KEY_I))
{
pause_pools();
itemsmenu();
}
if(key_pressed(KEY_W))
{
pause_pools();
weaponsmenu();
}
if(key_pressed(KEY_S))
{
string[] armor=find_directories("data/layouts/equipments/shields/*");
if(armor.length()==0)
{
speak("there are no shields available to view.");
}
else if(shieldon==1)
{
speak("You can't switch to a different shield while the current one is in use.");
}
else
{
destroy_all_shields();
string[] shieldlist=find_directories("data/layouts/equipments/shields/*");
for(uint i=0; i<shieldlist.length(); i++)
{
shieldparse(shieldlist[i]);
}
pause_pools();
string res=shieldsmenu();
if(res!="")
{
shieldtype=res;
}
}
}
if(key_repeating(KEY_TAB) and key_up(KEY_LMENU) and key_up(KEY_RMENU))
{
if (shift_is_down())
cycle_inv(0);
else
cycle_inv(1);
}
if(key_pressed(KEY_RETURN) and shift_is_down() and usetimer.elapsed>=usetime)
{
usetimer.restart();
if (inv.get_keys().length()>0 and invpos<inv.get_size())
useitem(inv.get_keys()[invpos]);
else
speak("No item in focus.");
}
if(key_pressed(KEY_LBRACKET) and shift_is_down() and usetimer.elapsed>=usetime)
{
if(inv.get_keys().length()>0 and invpos<inv.get_size())
{
string[] dropsfx=find_files("sounds/"+soundpack+"/equipments/items/unsorted/"+itemtype+"/"+itemtype2+"/*drop*");
if(dropsfx.length()!=0 and facing=="left") itemslot=p.play_extended_2d("sounds/"+soundpack+"/equipments/items/unsorted/"+itemtype+"/"+itemtype2+"/"+dropsfx[random(0,dropsfx.length()-1)],me.x-1,me.y,me.x-1,me.y,0,0,0,0,false,0,0,itemvolume,itempitch,false);
if(dropsfx.length()!=0 and facing=="right") itemslot=p.play_extended_2d("sounds/"+soundpack+"/equipments/items/unsorted/"+itemtype+"/"+itemtype2+"/"+dropsfx[random(0,dropsfx.length()-1)],me.x+1,me.y,me.x+1,me.y,0,0,0,0,false,0,0,itemvolume,itempitch,false);
drop_item(facing, itemtype, itemtype2);
give(itemtype2,-1);
usetimer.restart();
}
else
{
speak("No item in focus.");
}
}
if(shift_is_down())
{
if(key_pressed(KEY_LEFT))
{
spy("left", spydist);
}
if(key_pressed(KEY_RIGHT))
{
spy("right", spydist);
}
if(key_pressed(KEY_DOWN))
{
spy("down", spydist);
}
if(key_pressed(KEY_UP))
{
spy("up", spydist);
}
}
if(key_down(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(key_pressed(KEY_R))
{
bool hazard_found=false;
string tiletype;
if(cam.y>=1 and gct(cam.x,cam.y)=="")
{
tiletype="air";
}
else
{
tiletype=gct(cam.x,cam.y);
}
for(uint i=0; i<hazards.length(); i++)
{
if(cam.x>=hazards[i].minx && cam.x<=hazards[i].maxx && cam.y>=hazards[i].miny && cam.y<=hazards[i].maxy)
{
hazard_found=true;
speak(tiletype+" with "+hazards[i].hazardtype+" hazard, "+cam.x+","+cam.y);
break;
}
}
if(!hazard_found)
{
speak(tiletype+", "+cam.x+", "+cam.y);
}
}
if(key_pressed(KEY_M))
{
if(mfc==false)
{
mfc=true;
if(switchsound==1) p.play_stationary("toggleon.ogg",false);
speak("Mfwc enabled.");
}
else if(mfc==true)
{
mfc=false;
if(switchsound==1) p.play_stationary("toggleoff.ogg",false);
speak("Mfwc disabled.");
}
}
if(key_pressed(KEY_T))
{
playcam();
}
if(cleft.pressing() and cam.x!=0)
{
cam_left();
}
if(cright.pressing() and cam.x!=maxx)
{
cam_right();
}
if(key_pressed(KEY_LEFT) and cam.x!=0)
{
camstep_left();
}
if(key_pressed(KEY_RIGHT) and cam.x!=maxx)
{
camstep_right();
}
if(cdown.pressing() and cam.y!=0)
{
cam_down();
}
if(cup.pressing() and cam.y!=maxx)
{
cam_up();
}
if(key_pressed(KEY_DOWN) and cam.y!=0)
{
camstep_down();
}
if(key_pressed(KEY_UP) and cam.y!=maxy)
{
camstep_up();
}
}
if(key_up(KEY_G))
{
cam.x=me.x;
cam.y=me.y;
mfc=false;
}
if(key_pressed(KEY_SEMICOLON))
{
speak("Your maximum jump height is"+jumpheight+"squares");
}
if(key_pressed(KEY_APOSTROPHE))
{
speak("You are at speed"+modspeed);
}
if(key_down(KEY_LEFT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_left();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_down(KEY_RIGHT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_right();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_down(KEY_UP) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_up();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_down(KEY_DOWN) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_down();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_pressed(KEY_LEFT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_left();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_RIGHT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_right();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_UP) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_up();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_DOWN) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_down();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charrocksound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_D) and modspeed!=20)
{
if(keyrowhold==0)
{
speak("You must enable auto walking in order to increase the moving speed.");
}
else if(speedable==true)
{
modspeed+=1;
speak("speed"+modspeed);
}
}
if(key_pressed(KEY_A) and modspeed!=1)
{
if(keyrowhold==0)
{
speak("You must enable auto walking in order to decrease the moving speed.");
}
else if(speedable==true)
{
modspeed-=1;
speak("speed"+modspeed);
}
}
if(key_pressed(KEY_F))
{
if(modspeed==5)
{
speak("moving speed is already reset");
}
else if(modspeed<=20)
{
modspeed=5;
speak("moving speed reset");
}
}
if(key_pressed(KEY_X))
{
if(spokenswitch==1)
{
if(keyrowhold==1 and speedable==true)
{
if(switchsound==1) p.play_stationary("switchoff.ogg",false);
speak("auto walking disabled");
keyrowhold=0;
speedable=false;
}
else if(keyrowhold==0 and speedable==false)
{
if(switchsound==1) p.play_stationary("switchon.ogg",false);
speak("auto walking enabled");
keyrowhold=1;
speedable=true;
}
else if(spokenswitch==0)
{
if(keyrowhold==1 and speedable==true)
{
if(switchsound==1) p.play_stationary("switchoff.ogg",false);
keyrowhold=0;
speedable=false;
}
else if(keyrowhold==0 and speedable==false)
{
if(switchsound==1) p.play_stationary("switchon.ogg",false);
keyrowhold=1;
speedable=true;
}
}
}
}
if(key_pressed(KEY_C))
{
speakcoordinates();
}
if(key_pressed(KEY_Q))
{
if(get_zone_at(me.x, me.y)!="")
{
string locate=get_zone_at(me.x,me.y);
speak("Current location"+","+locate);
}
else
{
speak("Current location"+","+"unknown area.");
}
}
if(key_down(KEY_SPACE) and key_up(KEY_G)  and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and autojump==1 and jumping==0 and jumpable==true and falling==false and doormove==false and psdoormove==false)
{
string[] jumpsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*jump*");
if(jumpsfx.length()!=0 and charjumpsound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+jumpsfx[random(0,jumpsfx.length()-1)],false);
ty1=me.y;
ty2=me.y+jumpheight;
jumping=1;
ascending=true;
}
if (jumping==1)
{
if (atapex==true and jumptimer.elapsed>=apextime)
{
jumptimer.restart();
atapex=false;
}
if (ascending==false and jumptimer.elapsed>=jumptime2 and atapex==false)
{
jumptimer.restart();
me.y-=1;
checkforplatforms();
if (me.y<=ty1)
{
me.y=ty1;
jumping=0;
}
}
if (ascending==true and jumptimer.elapsed>=jumptime)
{
jumptimer.restart();
me.y+=1;
checkforwalls();
if (me.y>=ty2)
{
ascending=false;
jumptimer.restart();
atapex=true;
}
}
}
if(key_pressed(KEY_SPACE) and key_up(KEY_G)  and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and autojump==0 and jumping==0 and jumpable==true and falling==false and doormove==false and psdoormove==false)
{
string[] jumpsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*jump*");
if(jumpsfx.length()!=0 and charjumpsound==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+jumpsfx[random(0,jumpsfx.length()-1)],false);
ty1=me.y;
ty2=me.y+jumpheight;
jumping=1;
ascending=true;
}
if (jumping==1)
{
if (atapex==true and jumptimer.elapsed>=apextime)
{
jumptimer.restart();
atapex=false;
}
if (ascending==false and jumptimer.elapsed>=jumptime2 and atapex==false)
{
jumptimer.restart();
me.y-=1;
checkforplatforms();
if (me.y<=ty1)
{
me.y=ty1;
jumping=0;
}
}
if (ascending==true and jumptimer.elapsed>=jumptime)
{
jumptimer.restart();
me.y+=1;
checkforwalls();
if (me.y>=ty2)
{
ascending=false;
jumptimer.restart();
atapex=true;
}
}
}
if(key_pressed(KEY_Z))
{
if(melee==false and weapontype=="archery")
{
speak(loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve");
}
if(melee==false and weapontype=="artillery")
{
speak(loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve");
}
if(melee==false and weapontype=="explosive")
{
speak(loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve");
}
if(melee==true and weapontype=="melee")
{
speak("This weapon does not take any ammo.");
}
}
if(key_pressed(KEY_R) and melee==false and loadedammo<=0)
{
reload_weapon();
}
if(key_pressed(KEY_Y))
{
speak("You've been playing for a total of;"+timeelapsed.m()+"minutes,"+timeelapsed.s()+"seconds");
}
if(key_pressed(KEY_H))
{
if(shieldon==1)
{
speak("Your shield must be unequipped to view the player's health status.");
}
else if(shieldon==0)
{
if(healthspeech==1 and lifecard>=2)
{
speak(health+"health,"+lifecard+"lives");
}
if(healthspeech==2 and lifecard>=2)
{
speak(health+"of"+maxhealth+"health,"+lifecard+"lives");
}
if(healthspeech==3 and lifecard>=2)
{
speak(round(health/maxhealth*100,2)+"percent health remaining,"+lifecard+"lives");
}
if(healthspeech==4 and lifecard>=2)
{
speak(round(health/maxhealth*100,2)+"percent,"+health+"of"+maxhealth+"health,"+lifecard+"lives");
}
if(healthspeech==1 and lifecard<=1)
{
speak(health+"health,"+lifecard+"life");
}
if(healthspeech==2 and lifecard<=1)
{
speak(health+"of"+maxhealth+"health,"+lifecard+"life");
}
if(healthspeech==3 and lifecard<=1)
{
speak(round(health/maxhealth*100,2)+"percent health remaining,"+lifecard+"life");
}
if(healthspeech==4 and lifecard<=1)
{
speak(round(health/maxhealth*100,2)+"percent,"+health+"of"+maxhealth+"health,"+lifecard+"life");
}
}
}
if(key_pressed(KEY_M))
{
if(shieldon==0)
{
speak("Your shield must be equipped to view it's status.");
}
else if(shieldon==1)
{
speak("shield strength,"+round(shieldstrength/maxshieldstrength*100,2)+"percent");
}
}
if(control_is_down())
{
if(useitems==false)
{
drawable=true;
auto_fire_weapon();
}
else if(useitems==true)
{
drawable=false;
auto_use_item();
}
}
if(key_pressed(KEY_LCONTROL) or key_pressed(KEY_RCONTROL))
{
if(useitems==false)
{
drawable=true;
manule_fire_weapon();
}
else if(useitems==true)
{
drawable=false;
manule_use_item();
}
}
if(key_pressed(KEY_E))
{
if(objinf==1)
{
if(animals.length()==0 and bullets.length()==0 and doors.length()==0 and psdoors.length()==0 and enemies.length()==0 and projectiles.length()==0 and robots.length()==0 and spikes.length()==0  and turrets.length()==0 and vehicles.length()==0 and walls.length()==0 and zombies.length()==0)
{
speak("there are no objects on the field to view.");
}
else
{
pause_pools();
objinfo();
}
}
if(key_pressed(KEY_N))
{
speak("You have killed a total of"+kills+"enemies.");
}
if(key_pressed(KEY_P))
{
if(pausem==0)
{
if(paused==0)
{
p.play_stationary("pause.ogg",false);
pause_game();
}
else if(paused==1)
{
p.play_stationary("resume.ogg",false);
resume_game();
}
}
else if(pausem==1)
{
pausemenu();
}
}
if(key_pressed(KEY_V))
{
pause_pools();
pointsmenu();
}
if(key_pressed(KEY_BACKSLASH) and healable==true)
{
if(shieldon==1)
{
speak("Your shield must be unequipped to restore the player's health.");
}
else if(shieldon==0 and hprestoration==0 and health>=maxhealth)
{
speak("You're already at maximum health.");
}
else if(health<=maxhealth and hprestoration==1)
{
p.destroy_sound(autoslot);
string[] healstopsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
hprestoration=0;
}
else
{
string[] healstartsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healstart*");
if(healstartsfx.length()!=0 and charhealsound2==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healstartsfx[random(0,healstartsfx.length()-1)],false);
hprestoration=1;
}
}
if(key_pressed(KEY_RBRACKET) and healable==true)
{
if(shieldon==0)
{
speak("Your shield must be equipped to restore it's strength.");
}
else if(shieldon==1 and shieldstrength>=maxshieldstrength)
{
speak("Your shield is already at maximum strength.");
}
else if(shieldon==1 and shieldstrength<=maxshieldstrength)
{
if(sprestoration==1)
{
p.destroy_sound(autoslot);
string[] healstopsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
sprestoration=0;
}
else
{
string[] healstartsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*healstart*");
if(healstartsfx.length()!=0 and charhealsound2==1) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+healstartsfx[random(0,healstartsfx.length()-1)],false);
sprestoration=1;
}
}
}
if(key_pressed(KEY_B))
{
if(shieldtype=="none")
{
speak("You must draw a shield before equipping it.");
}
else if(shieldon==0)
{
p.destroy_sound(shieldwearslot);
string[] wearsfx=find_files("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*wear*");
if(wearsfx.length()!=0 and shieldwearsound==1) shieldwearslot=p.play_stationary_extended("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+wearsfx[random(0,wearsfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
string[] shieldsfx=find_files("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*loop*");
if(shieldsfx.length()!=0 and shieldloopsound==1) shieldloop=p.play_stationary_extended("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+shieldsfx[random(0,shieldsfx.length()-1)],true,0,0,shieldvolume,shieldpitch,false);
shieldon=1;
}
else
{
p.destroy_sound(shieldloop);
p.destroy_sound(shieldremoveslot);
string[] remsfx=find_files("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*remove*");
if(remsfx.length()!=0 and shieldremovesound==1) shieldremoveslot=p.play_stationary_extended("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+remsfx[random(0,remsfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
shieldon=0;
}
}
if(key_pressed(KEY_ESCAPE) and quittable==true)
{
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
me.x=0;
me.y=0;
mainmenu();
}
}
}
}
void playcam()
{
for (uint i = 0; i < hazards.length(); i++)
{
if(cam.x>=hazards[i].minx && cam.x<=hazards[i].maxx && cam.y>=hazards[i].miny && cam.y<=hazards[i].maxy)
{
if(mfc==true) camslot=campool.play_stationary("camerahazard.ogg",false);
if(mfc==false) camslot=campool.play_2d("camerahazard.ogg",me.x,me.y,cam.x,cam.y,false);
}
}
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=cam.x and walls[i].maxx>=cam.x and walls[i].miny<=cam.y and walls[i].maxy>=cam.y)
{
string[] wallers=find_files("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/*wall*");
if(wallers.length()!=0 and mfc==true) camslot=campool.play_stationary_extended("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/"+wallers[random(0,wallers.length()-1)],false,0,0,cameravolume,camerapitch);
if(wallers.length()!=0 and mfc==false) camslot=campool.play_extended_2d("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/"+wallers[random(0,wallers.length()-1)],me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
cbounce();
return;
}
}
if(gct(cam.x, cam.y)=="" || gct(cam.x, cam.y)=="air")
{
string[] camsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*cameraair*");
if(camsfx.length()!=0 and charsitsound==1 and mfc==true) camslot=campool.play_stationary_extended("sounds/"+soundpack+"/characters/"+chartype+"/"+camsfx[random(0,camsfx.length()-1)],false,0,0,cameravolume,100,false);
if(camsfx.length()!=0 and charsitsound==1 and mfc==false) camslot=campool.play_extended_2d("sounds/"+soundpack+"/characters/"+chartype+"/"+camsfx[random(0,camsfx.length()-1)],me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,100,false);
}
else
{
string[] tilers=find_files("sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/*step*");
if(tilers.length()!=0 and mfc==true) camslot=campool.play_stationary_extended("sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/"+tilers[random(0,tilers.length()-1)],false,0,0,cameravolume,camerapitch);
if(tilers.length()!=0 and mfc==false) camslot=campool.play_extended_2d("sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/"+tilers[random(0,tilers.length()-1)],me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
}
}
void playstep()
{
string current_text;
if(is_in_blockage(current_text))
{
speak(current_text);
pbounce();
return;
}
for(uint i=0; i<signs.length(); i++)
{
string[] signsfx=find_files("sounds/"+soundpack+"/objects/signs/"+signs[i].signtype+"/*step*");
if(signsfx.length()!=0 and signs[i].looping==false) signs[i].signsound=signpool.play_2d("sounds/"+soundpack+"/objects/signs/"+signs[i].signtype+"/"+signsfx[random(0,signsfx.length()-1)],me.x,me.y,signs[i].signx,signs[i].signy,false);
}
for(uint i=0; i<forcefields.length(); i++)
{
if(forcefields[i].forcefielded==true && forcefields[i].minx<=me.x && forcefields[i].maxx>=me.x && forcefields[i].miny<=me.y && forcefields[i].maxy>=me.y && shieldon==1 && shieldstrength<=maxshieldstrength && paused==0)
{
string[] arqsfx=find_files("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*");
if(arqsfx.length()!=0 && shieldhitsound==1) shieldslot=p.play_stationary_extended("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+arqsfx[random(0,arqsfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
string[] hitsfx=find_files("sounds/"+soundpack+"/objects/force fields/"+forcefields[i].forcetype+"/*hit*");
if(hitsfx.length()!=0) forcefields[i].wepsound=forcepool.play_stationary_extended("sounds/"+soundpack+"/objects/force fields/"+forcefields[i].forcetype+"/"+hitsfx[random(0,hitsfx.length()-1)],false,0,0,painvolume,painpitch,false);
shieldstrength-=forcefields[i].damage-shielddefence;
pbounce();
return;
}
else if(forcefields[i].forcefielded==true && forcefields[i].minx<=me.x && forcefields[i].maxx>=me.x && forcefields[i].miny<=me.y && forcefields[i].maxy>=me.y && shieldon==0 && paused==0)
{
string[] hitsfx=find_files("sounds/"+soundpack+"/objects/force fields/"+forcefields[i].forcetype+"/*hit*");
if(hitsfx.length()!=0) forcefields[i].wepsound=forcepool.play_stationary_extended("sounds/"+soundpack+"/objects/force fields/"+forcefields[i].forcetype+"/"+hitsfx[random(0,hitsfx.length()-1)],false,0,0,painvolume,painpitch,false);
string[] hurtsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*hurt*");
if(hurtsfx.length()!=0 && charhurtsound==1) painslot=p.play_stationary_extended("sounds/"+soundpack+"/characters/"+chartype+"/"+hurtsfx[random(0,hurtsfx.length()-1)],false,0,0,painvolume,painpitch,false);
health-=forcefields[i].damage-defence;
pbounce();
return;
}
}
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=me.x and walls[i].maxx>=me.x and walls[i].miny<=me.y and walls[i].maxy>=me.y)
{
wallvolume=walls[i].volume;
wallpitch=walls[i].pitch;
string[] wallers=find_files("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/*wall*");
if(wallers.length()!=0) wallslot=p.play_extended_2d("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/"+wallers[random(0,wallers.length()-1)],me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
string[] tilers=find_files("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*step*");
if(tilers.length()!=0 and jumping==0) tileslot=p.play_stationary_extended("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/"+tilers[random(0,tilers.length()-1)],false,0,0,tilevolume,tilepitch);
}
void playfall()
{
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=me.x and walls[i].maxx>=me.x and walls[i].miny<=me.y and walls[i].maxy>=me.y)
{
wallvolume=walls[i].volume;
wallpitch=walls[i].pitch;
string[] wallers=find_files("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/*wall*");
if(wallers.length()!=0) wallslot=p.play_extended_2d("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/"+wallers[random(0,wallers.length()-1)],me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
return;
}
}
if(tilename!="hardland")
{
string [] tilers=find_files("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*hardland*");
if(tilers.length()!=0) tilename=tilers[random(0,tilers.length()-1)];
if(tilers.length()!=0) tileslot=p.play_stationary_extended("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/"+tilename,false,0,0,tilevolume,tilepitch);
}
}
void playland()
{
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=me.x and walls[i].maxx>=me.x and walls[i].miny<=me.y and walls[i].maxy>=me.y)
{
wallvolume=walls[i].volume;
wallpitch=walls[i].pitch;
string[] wallers=find_files("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/*wall*");
if(wallers.length()!=0) wallslot=p.play_extended_2d("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/"+wallers[random(0,wallers.length()-1)],me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
return;
}
}
if(tilename!="land")
{
string [] tilers=find_files("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*land*");
for (uint i=0; i<tilers.length(); i++)
{
if(string_contains(tilers[i],"hard",1)>-1)
tilers.remove_at(i);
}
if(tilers.length()!=0) tilename=tilers[random(0,tilers.length()-1)];
if(tilers.length()!=0) tileslot=p.play_stationary_extended("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/"+tilename,false,0,0,tilevolume,tilepitch);
}
}
void cbounce()
{
if(camdir=="right")
cam.x--;
else if(camdir=="left")
cam.x++;
else if(camdir=="up")
cam.y--;
else if(camdir=="down")
cam.y++;
}
void pbounce()
{
if(facing=="right")
me.x--;
else if(facing=="left")
me.x++;
else if(facing=="up")
me.y--;
else if(facing=="down")
me.y++;
}
void checkforplatforms()
{
if (gmt(me.x,me.y)!="")
{
playland();
jumping=0;
falling=false;
}
}
void checkforwalls()
{
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=me.x and walls[i].maxx>=me.x and walls[i].miny<=me.y and walls[i].maxy>=me.y)
{
wallvolume=walls[i].volume;
wallpitch=walls[i].pitch;
string[] wallers=find_files("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/*wall*");
if(wallers.length()!=0) wallslot=p.play_extended_2d("sounds/"+soundpack+"/objects/walls/"+walls[i].wall+"/"+wallers[random(0,wallers.length()-1)],me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
ascending=false;
jumptimer.restart();
atapex=true;
}
}
}
void fallcheck()
{
if(jumping==0 && falling==false && (gmt(me.x,me.y)==""||gmt(me.x,me.y)=="air") && doormove==false && psdoormove==false && me.y>0)
{
falling=true;
string[] fallsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*fall*");
if(fallsfx.length()!=0 and charfallsound==1 and me.y>=8) p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+fallsfx[random(0,fallsfx.length()-1)],false);
string[] fallinsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*plummet*");
if(fallinsfx.length()!=0 and charfallsound2==1 and me.y>=8) fallslot=p.play_stationary("sounds/"+soundpack+"/characters/"+chartype+"/"+fallinsfx[random(0,fallinsfx.length()-1)],false);
}
if(falling)
{
if(falltimer.elapsed>=falltime&&me.y>0)
{
falltimer.restart();
me.y--;
fallcounter++;
}
if(gmt(me.x, me.y)!="" && gmt(me.x, me.y)!="air")
{
if(fallcounter>=1 and p.sound_is_playing(fallslot)) p.destroy_sound(fallslot);
string[] arqsfx=find_files("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*");
if(arqsfx.length()!=0 and shieldhitsound==1 and fallcounter>=8 and shieldon==1) shieldslot=p.play_stationary_extended("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+arqsfx[random(0,arqsfx.length()-1)],false,0,0,shieldvolume,shieldpitch);
string[] hurtsfx=find_files("sounds/"+soundpack+"/characters/"+chartype+"/*hurt*");
if(hurtsfx.length()!=0 and charhurtsound==1 and fallcounter>=8 and shieldon==0) painslot=p.play_stationary_extended("sounds/"+soundpack+"/characters/"+chartype+"/"+hurtsfx[random(0,hurtsfx.length()-1)],false,0,0,painvolume,painpitch,false);
if(fallcounter>=8) jumpable=false;
if(fallcounter>=8) moveable=false;
if(fallcounter>=8) sitting=true;
if(fallcounter<=7) playland();
else if(fallcounter>7)
{
playfall();
if(fallcounter>=8 and shieldon==0) health-=fallcounter*21-defence;
if(fallcounter>=8 and shieldon==1) shieldstrength-=fallcounter*21-shielddefence;
}
falling=false;
fallcounter=0;
for(uint i=0; i<checkpoints.length(); i++)
{
if(me.x==checkpoints[i].checkx and me.y==checkpoints[i].checky)
{
//checkpool.destroy_sound(checkpoints[i].checksound);
string[]getsfx=find_files("sounds/"+soundpack+"/objects/checkpoints/"+checkpoints[i].checktype+"/*get*");
if(getsfx.length()!=0) checkpoints[i].getsound=checkpool.play_stationary_extended("sounds/"+soundpack+"/objects/checkpoints/"+checkpoints[i].checktype+"/"+getsfx[random(0,getsfx.length()-1)],false,0,0,itemvolume,itempitch,false);
@last_checkpoint=checkpoints[i];
checkpoints.remove_at(i);
return;
}
}
}
}
}
